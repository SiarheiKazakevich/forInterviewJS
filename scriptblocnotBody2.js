function createBlocnotBody2() {
  try {
    let blocnotContainer = document.createElement("div");
    blocnotContainer.classList.add("blocnotBody");
    blocnotContainer.style.display = "flex";
    blocnotContainer.style.justifyContent = "center";
    blocnotContainer.style.alignItems = "center";
    blocnotContainer.style.flexDirection = "column";

    let qaPairs = [
      {
        question:
          "Вопрос 2.1: Если бы вы присоединились к проекту и команда разработчиков использовала табы, а вы пробелы, что бы вы сделали в таком случае?",
        answer: `[Вопрос с подвохом] — Наиболее правильный ответ будет заключаться в том, чтобы использовать стандартный инструмент форматирования, вроде Prettier, чтобы код любого члена команды выглядел одинаково при отправке в репозиторий. Таким образом, вы сможете продолжать использовать пробелы, а команда сможет свободно использовать табы.

        Если вы будете навязывать свое мнение остальным разработчикам, то вас вряд ли будут считать командным игроком, а если вы начнете использовать табы без особого желания, то вы не будете так мотивированы, как все остальные, и с большой вероятностью уйдете.`,
      },
      {
        question:
          "Вопрос 2.2: Что вдохновляет или интересует вас в программировании?",
        answer: ``,
      },
      {
        question: "Вопрос 2.3: Что нового вы узнали вчера/на этой неделе?",
        answer: ``,
      },
      {
        question: "Вопрос 2.4: Расскажите о предпочитаемой среде разработки. ",
        answer: ``,
      },
      {
        question:
          "Вопрос 2.5: Если бы вы могли освоить одну технологию в этом году, что бы это было?",
        answer: ``,
      },
      {
        question:
          "Вопрос 2.6: Как на предыдущей работе вы решили последнее разногласие с вашим начальником? Чем все закончилось? Не могли бы вы дать номер вашего начальника, чтобы я мог проверить его версию?",
        answer: `[Последний вопрос — блеф, ни у кого нет времени звонить вашему бывшему начальнику]`,
      },
      {
        question:
          "Вопрос 2.7: Какие ресурсы, форумы или инструменты вы используете, чтобы узнавать о последних тенденциях во фронтенд-разработке и дизайне? Есть ли среди них фавориты, какие и почему?",
        answer: ``,
      },
      {
        question:
          "Вопрос 2.8: Можете ли вы описать свой рабочий процесс при создании веб-страницы? Какие первые пять шагов вы проделываете при создании нового проекта?",
        answer: ``,
      },

      {
        question:
          "Вопрос 2.9: С какой технической проблемой вы столкнулись в последний раз и как вы ее решили?",
        answer: ``,
      },
      {
        question:
          "Вопрос 2.10: Какие действия вы предприняли в отношении последних проектов, чтобы повысить удобство поддержки кода? Какие-либо конкретные парадигмы программирования, вроде функционального программирования или разработки через тестирование?",
        answer: ``,
      },
      {
        question:
          "Вопрос 2.11: С какими системами контроля версий вы знакомы? Как вы делитесь кодом между проектами без потерь?",
        answer: `Я знаком с несколькими системами контроля версий, включая:

1.Git: Наиболее популярная и широко используемая система контроля версий. Git предоставляет распределенную систему контроля версий и позволяет каждому разработчику иметь полную копию истории разработки. Популярные платформы, использующие Git, включают GitHub, GitLab и Bitbucket.

2.Subversion (SVN): Централизованная система контроля версий, которая была популярна до появления Git. SVN использует централизованное хранилище, и все изменения кода сохраняются на одном сервере.

3.Mercurial: Еще одна распределенная система контроля версий, похожая на Git. Mercurial стремится к простоте и высокой производительности.

4.Perforce: Коммерческая централизованная система контроля версий, известная своей производительностью при работе с большими кодовыми базами и файлами.

5.CVS (Concurrent Versions System): Одна из старейших систем контроля версий. На данный момент CVS менее популярен по сравнению с более современными системами, такими как Git и SVN.`,
      },
      {
        question:
          "Вопрос 2.12: Назовите четыре способа уменьшить время загрузки страницы.",
        answer: `
        Уменьшение времени загрузки страницы является важным аспектом оптимизации веб-сайта, который может значительно улучшить пользовательский опыт. Вот четыре способа достичь этого:
        
        1.Минимизация и сжатие ресурсов:
        Минификация: Удаление лишних пробелов, комментариев и сокращение имен переменных в CSS, JavaScript и HTML файлах.
        Сжатие: Использование таких алгоритмов сжатия, как Gzip или Brotli, для уменьшения размера передаваемых файлов.
        
        2.Оптимизация изображений:
        Сжатие изображений: Использование инструментов для сжатия изображений без потери качества, таких как ImageOptim, TinyPNG или Squoosh.
        Использование современных форматов: Применение современных форматов изображений, таких как WebP, которые имеют меньший размер по сравнению с традиционными JPEG и PNG.
        
        3.Использование кэширования:
        Кэширование в браузере: Настройка заголовков кэширования, чтобы браузеры могли хранить статические ресурсы на клиентской стороне и загружать их повторно при последующих визитах.
        Кэширование на стороне сервера: Использование механизмов кэширования на сервере для уменьшения нагрузки и ускорения времени отклика.
        Асинхронная загрузка и задержка загрузки (lazy loading):
        
        4.Асинхронная загрузка JavaScript: Использование атрибутов async и defer для загрузки скриптов без блокировки рендеринга страницы.
        Lazy loading для изображений и видео: Отложенная загрузка медиафайлов до тех пор, пока они не понадобятся (например, пока пользователь не прокрутит до них).
        
        Эти методы помогут значительно сократить время загрузки страницы и улучшить производительность вашего веб-сайта.`,
      },
      {
        question:
          "Вопрос 2.13: Как расшифровывается CORS и к какой проблеме это относится?",
        answer: `CORS расшифровывается как Cross-Origin Resource Sharing (совместное использование ресурсов между различными источниками).

        CORS относится к проблеме безопасности в веб-разработке, связанной с ограничениями, накладываемыми браузерами для защиты от атак типа "Cross-Site Scripting" (XSS) и "Cross-Site Request Forgery" (CSRF). Эти ограничения называются "политикой одинакового происхождения" (same-origin policy), которая запрещает веб-странице делать запросы на ресурсы с другого домена, если они не находятся в том же происхождении (протокол, домен и порт должны совпадать).
        
        CORS позволяет веб-сайтам явно разрешать доступ к своим ресурсам из других источников, изменяя заголовки HTTP. Это позволяет безопасно обходить политику одинакового происхождения, предоставляя разработчикам возможность загружать ресурсы с других доменов, но только в том случае, если сервер разрешает такие запросы через соответствующие заголовки.`,
      },
      {
        question:
          "Вопрос 2.14: Объясните, что такое ARIA и экранные считывающие устройства, а также как сделать веб-сайт доступным для людей с ограниченными возможностями.",
        answer: `ARIA (Accessible Rich Internet Applications) - это набор атрибутов, предназначенных для улучшения доступности веб-контента и веб-приложений для людей с ограниченными возможностями. ARIA помогает разработчикам сделать веб-контент более доступным для пользователей, которые используют вспомогательные технологии, такие как экранные считывающие устройства.

        Экранные считывающие устройства (screen readers) - это программы, которые преобразуют текст и другие элементы интерфейса в аудио или выводят их на дисплеи Брайля. Они помогают людям с нарушениями зрения взаимодействовать с компьютерами и мобильными устройствами, предоставляя аудиоописания содержимого и функциональности веб-страниц.
        
        Как сделать веб-сайт доступным для людей с ограниченными возможностями
        1.Использование ARIA-атрибутов:
        
        Атрибуты ARIA (например, aria-label, aria-labelledby, aria-describedby, aria-live, role и т.д.) добавляются к HTML-элементам для предоставления дополнительной информации экранным считывающим устройствам.
        Пример: <button aria-label="Submit form">Submit</button>
        2.Семантический HTML:
        
        Используйте правильные семантические элементы HTML (<header>, <nav>, <main>, <article>, <section>, <footer> и т.д.) для структурирования контента.
        Пример: <nav>, <article>, <header>
        3.Текстовые альтернативы:
        
        Добавляйте текстовые альтернативы для изображений с использованием атрибута alt.
        Пример: <img src="logo.png" alt="Company Logo">
        4.Фокус и навигация:
        
        Убедитесь, что пользователи могут легко перемещаться по веб-сайту с клавиатуры. Все интерактивные элементы должны быть доступны с помощью клавиши Tab.
        Используйте атрибуты tabindex для управления порядком фокусировки.
        Пример: <button tabindex="0">Click me</button>
        5.Цвета и контраст:
        
        Используйте достаточный контраст между текстом и фоном для улучшения читаемости.
        Пример: Проверьте контрастность с помощью инструментов, таких как WebAIM.
        6.Респонсивный дизайн:
        
        Убедитесь, что веб-сайт адаптируется к различным размерам экрана и устройствам.
        Используйте гибкие макеты и медиа-запросы в CSS.
        7.Заголовки и структуру:
        
        Используйте заголовки (<h1>, <h2>, <h3> и т.д.) для логической структуры контента.
        Пример: <h1>Main Title</h1>, <h2>Section Title</h2>
        8.ARIA Live Regions:
        
        Используйте атрибуты aria-live для динамического контента, чтобы экранные считывающие устройства уведомляли пользователей о новых или измененных элементах.
        Пример: <div aria-live="polite">New content loaded</div>
        9.Формы:
        
        Убедитесь, что формы имеют метки (<label>) для всех элементов ввода.
        Пример: <label for="username">Username</label><input id="username" type="text">
        Соблюдение этих рекомендаций поможет создать веб-сайт, который будет доступен и удобен для всех пользователей, включая людей с ограниченными возможностями.`,
      },
      {
        question: "Вопрос 2.15: Для чего используется doctype?",
        answer: `<!DOCTYPE> используется в HTML для указания типа документа и версии HTML, которую использует страница. Он сообщает браузеру, как следует интерпретировать и рендерить содержимое веб-страницы. Правильное использование <!DOCTYPE> позволяет браузеру работать в стандартахом режиме, избегая квиркс-режима (quirks mode), который может вызывать несовместимости и непредсказуемое поведение при рендеринге страниц.

        Примеры использования <!DOCTYPE>
        1.HTML5:
        <!DOCTYPE html>
        -Это наиболее часто используемый и рекомендуемый DOCTYPE для современных веб-страниц. Он минимален и говорит браузерам, что страница использует HTML5.
        
        2.HTML 4.01 Strict:
        <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
        -Указывает, что страница соответствует строгому режиму HTML 4.01, где запрещены устаревшие теги и атрибуты.
        
        3.HTML 4.01 Transitional:
        <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
        -Указывает на использование переходного режима HTML 4.01, который допускает устаревшие теги и атрибуты.
        
        4.XHTML 1.0 Strict:
        <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
        Указывает, что страница использует строгий режим XHTML 1.0, где синтаксис HTML должен соответствовать стандартам XML.
        
        5.XHTML 1.0 Transitional:
        <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
        -Указывает на использование переходного режима XHTML 1.0, который допускает использование устаревших тегов и атрибутов.
        
        --Зачем нужен <!DOCTYPE>:
        
        1.Режим совместимости:
        Браузеры используют <!DOCTYPE> для определения режима рендеринга. Без него некоторые браузеры могут работать в режиме совместимости (quirks mode), что может привести к неправильному отображению страниц.
        
        2.Поддержка стандартов:
        <!DOCTYPE> помогает браузерам рендерить страницы в соответствии с веб-стандартами, что обеспечивает более предсказуемое и совместимое поведение между различными браузерами.
        
        3.Разработка и отладка:
        Наличие <!DOCTYPE> облегчает отладку и разработку веб-страниц, так как оно заставляет браузеры рендерить страницы в режиме стандартов, где ошибки и некорректное поведение проще обнаружить и исправить.
        
        Использование правильного <!DOCTYPE> важно для обеспечения корректного отображения и функционирования веб-страниц в различных браузерах и устройствах.`,
      },
      {
        question: "Вопрос 2.16: Перечислите структурные блоки в HTML5.",
        answer: `В HTML5 были введены новые семантические элементы, которые помогают улучшить структуру и понятность веб-страниц как для разработчиков, так и для поисковых систем и вспомогательных технологий. Вот некоторые из основных структурных блоков в HTML5:

        1.<header> - используется для определения заголовка документа или секции. Он может содержать заголовочные элементы, логотипы, навигационные элементы и другие вводные элементы.
       2.<nav> - предназначен для определения навигационных ссылок. Обычно используется для основного меню сайта.
       3.<section> - используется для разделения контента на тематические блоки. Каждый <section> должен содержать заголовок.
       4.<article> - представляет собой независимый фрагмент контента, который может быть отдельно от остального сайта, например, статью, пост в блоге или новость.
       5.<aside> - используется для контента, который связан с основным содержимым, но не является его частью, например, боковые панели, блоки с дополнительной информацией или ссылки.
       6.<footer> - представляет нижнюю часть документа или секции. Обычно содержит информацию об авторских правах, ссылки на политику конфиденциальности, контактную информацию и т.д.
       7.<main> - определяет основной контент документа, уникальный для данной страницы. Должен содержать центральное содержание страницы, исключая повторяющиеся элементы, такие как навигационные ссылки и боковые панели.
       8.<figure> и <figcaption> - используются для обозначения самостоятельного содержимого, такого как изображение или диаграмма, с пояснением или подписью.

       Эти элементы помогают создать более логичную и легко читаемую структуру веб-страницы, улучшая доступность и SEO-оптимизацию.
        `,
      },
      {
        question:
          "Вопрос 2.17: В чем разница между localStorage, файлами cookie и sessionStorage?",
        answer: `localStorage, sessionStorage и файлы cookie - это разные механизмы для хранения данных на стороне клиента в веб-приложениях. Вот их основные различия:

        -localStorage
        1.Время жизни данных:
        Данные в localStorage сохраняются бессрочно, пока их явно не удалят с помощью JavaScript или вручную пользователем.
        
        2.Область видимости:
        Данные в localStorage доступны на всех страницах одного и того же происхождения (тот же домен, протокол и порт).
        
        3.Размер хранения:
        Обычно может хранить до 5-10 МБ данных, в зависимости от браузера.
        
        4.Пример использования:
        
        javascript
        Копировать код
        // Сохранение данных
        localStorage.setItem('key', 'value');
        // Получение данных
        let value = localStorage.getItem('key');
        // Удаление данных
        localStorage.removeItem('key');
        // Очистка всех данных
        localStorage.clear();
        -sessionStorage
        1.Время жизни данных:
        
        Данные в sessionStorage сохраняются до закрытия вкладки браузера.
        2.Область видимости:
        
        Данные в sessionStorage доступны только в текущей вкладке или окне браузера. Они не будут доступны в других вкладках или окнах, даже если они открыты на той же странице.
        3.Размер хранения:
        
        Обычно может хранить до 5-10 МБ данных, в зависимости от браузера.
        4.Пример использования:
        
        javascript
        Копировать код
        // Сохранение данных
        sessionStorage.setItem('key', 'value');
        // Получение данных
        let value = sessionStorage.getItem('key');
        // Удаление данных
        sessionStorage.removeItem('key');
        // Очистка всех данных
        sessionStorage.clear();
        -Файлы cookie
        1.Время жизни данных:
        
        Время жизни зависит от параметра expires или max-age, установленного при создании cookie. Cookie может быть удален после закрытия браузера (если это сессионное cookie) или сохраняться до установленного времени истечения.
        2.Область видимости:
        
        Cookie доступны на всех страницах одного и того же домена. Можно настроить доступ к cookie для определенных путей и субдоменов.
        3.Размер хранения:
        
        Ограничены примерно 4 КБ на один cookie. Общее количество cookie на домен также ограничено.
        4.Пример использования:
        
        javascript
        Копировать код
        // Сохранение cookie
        document.cookie = "key=value; expires=Fri, 31 Dec 9999 23:59:59 GMT; path=/";
        // Получение cookie
        let cookies = document.cookie.split(';').reduce((acc, cookie) => {
            let [key, value] = cookie.split('=').map(c => c.trim());
            acc[key] = value;
            return acc;
        }, {});
        let value = cookies['key'];
        -Основные отличия
        1.Время жизни:
        
        .localStorage: Постоянно (пока не удалено).
        .sessionStorage: До закрытия вкладки/окна браузера.
        .Файлы cookie: Зависит от установленного времени истечения.
        2.Область видимости:
        
        .localStorage: Все вкладки и окна одного и того же происхождения.
        .sessionStorage: Только текущая вкладка или окно.
        .Файлы cookie: Все вкладки и окна одного и того же домена (настроено через атрибуты).
        3.Размер хранения:
        
        .localStorage и sessionStorage: До 5-10 МБ.
        .Файлы cookie: Около 4 КБ на один cookie.
        4.Применение:
        
        .localStorage: Хранение данных, которые должны сохраняться между сессиями.
        .sessionStorage: Хранение данных, которые нужны только в рамках одной сессии.
        .Файлы cookie: Хранение данных, которые должны быть переданы на сервер с каждым запросом (например, аутентификационные токены, настройки пользователя).

        `,
      },
      {
        question: "Вопрос 2.18: Для чего подходят атрибуты data-?",
        answer: `Атрибуты data- (называемые также пользовательскими атрибутами или custom data attributes) используются для хранения произвольных данных в элементах HTML. Эти атрибуты позволяют разработчикам добавлять нестандартные данные к элементам HTML, которые можно легко получить и использовать с помощью JavaScript. Атрибуты data- не влияют на отображение элемента, но предоставляют способ хранить данные непосредственно в HTML-разметке.

        Примеры использования атрибутов data-
        1. Хранение данных в HTML:
        
        html
        Копировать код
        <div id="user" data-user-id="12345" data-user-role="admin">
            Имя пользователя
        </div>
        2. Доступ к данным с помощью JavaScript:
        
        javascript
        Копировать код
        // Получение элемента
        var userElement = document.getElementById('user');
        
        // Доступ к данным
        var userId = userElement.dataset.userId; // "12345"
        var userRole = userElement.dataset.userRole; // "admin"
        
        // Вывод данных в консоль
        console.log(userId, userRole);
        --Возможные применения атрибутов data-
        1. Передача данных из HTML в JavaScript:
        Атрибуты data- позволяют передавать данные, которые могут быть использованы скриптами на стороне клиента.
        
        2. Динамическое обновление контента:
        Использование data- атрибутов для хранения информации, которая может быть использована для динамического обновления контента без необходимости обращения к серверу.
        
        3. Хранение метаданных:
        Сохранение метаданных для элементов, которые могут быть использованы для различных целей, таких как аналитика или поведение интерфейса.
        
        4. Шаблоны и рендеринг:
        Использование data- атрибутов в шаблонах, чтобы хранить данные для последующего рендеринга динамического контента.
        
        --Преимущества использования атрибутов data-
        1.Простота и удобство:
        Атрибуты data- легко использовать и читать, так как они являются частью HTML-разметки и их синтаксис интуитивно понятен.
        
        2.Отсутствие влияния на рендеринг:
        Атрибуты data- не влияют на отображение элементов на странице, что делает их идеальными для хранения дополнительных данных.
        
        3.Совместимость:
        Атрибуты data- являются частью стандарта HTML5 и поддерживаются всеми современными браузерами.
        
        4.Гибкость:
        Разработчики могут использовать атрибуты data- для любых целей, не ограничиваясь фиксированными наборами данных.
        
        --Советы по использованию атрибутов data-
        1.Используйте описательные имена:
        Выбирайте описательные имена для data- атрибутов, чтобы было понятно, какие данные они хранят.
        
        html
        Копировать код
        <div data-product-id="67890" data-product-name="Widget">
            Название продукта
        </div>
        2.Избегайте избыточности:
        Не храните в data- атрибутах большие объемы данных или данные, которые легко можно получить другим способом.
        
        3.Безопасность:
        Помните, что данные в data- атрибутах видны в исходном коде страницы и могут быть изменены пользователями. Не храните в них конфиденциальную информацию.
        
        --Использование атрибутов data- - это мощный инструмент для улучшения взаимодействия между HTML и JavaScript, что позволяет создавать более интерактивные и динамичные веб-приложения.`,
      },
      {
        question:
          "Вопрос 2.19: К каким вещам следует относиться с осторожностью при проектировании или разработке многоязычных сайтов? Как вы обслуживаете страницу с контентом на нескольких языках?",
        answer: `
        Проектирование и разработка многоязычных сайтов требует особого внимания к различным аспектам, чтобы обеспечить удобство и корректность отображения контента для пользователей из разных языковых и культурных регионов. Вот несколько ключевых моментов, на которые следует обратить внимание:
        
        --Вещи, к которым следует относиться с осторожностью:
        1. Правильный выбор кодировки:
        
        Используйте UTF-8 для кодирования текста, чтобы обеспечить поддержку широкого диапазона символов.
        **html
        Копировать код
        <meta charset="UTF-8">
        2. Тексты и перевод:
        
        Убедитесь, что весь контент переведен корректно и культурно адекватно. Профессиональный перевод предпочтителен автоматическим инструментам.
        Избегайте использования встроенного текста (hardcoded text). Используйте файлы ресурсов или базы данных для хранения переводов.
        3. Форматы данных:
        
        Форматы даты, времени, чисел, валют и адресов могут сильно различаться между регионами. Используйте библиотеки и средства интернационализации для обработки этих форматов.
        4. Локализация:
        
        Обратите внимание на локальные особенности, такие как культурные различия, правовые требования и пользовательские предпочтения.
        5. Направление текста:
        
        Некоторые языки, такие как арабский и иврит, читаются справа налево. Убедитесь, что ваш сайт поддерживает и корректно отображает языки с различными направлениями текста.
        **html
        Копировать код
        <html lang="ar" dir="rtl">
        6. Пользовательский интерфейс и макет:
        
        Дизайн интерфейса должен быть адаптивным и учитывать возможное увеличение или уменьшение длины текста при переводе.
        7. SEO и URL:
        
        Оптимизируйте сайт для поисковых систем на каждом языке. Это может включать в себя использование hreflang атрибутов для указания языка и региона целевой аудитории.
        html
        Копировать код
        **<link rel="alternate" href="http://example.com/fr" hreflang="fr">
        <link rel="alternate" href="http://example.com/es" hreflang="es">
        8. Системы управления контентом (CMS):
        
        Выбирайте CMS, которая поддерживает многоязычность и предоставляет удобные инструменты для управления переводами.
        --Обслуживание страницы с контентом на нескольких языках:
        1. Структура URL:
        
        Используйте структуру URL, которая отражает язык контента. Например, поддомены (en.example.com), подкаталоги (example.com/en) или параметры URL (example.com?lang=en).
        2. Файлы перевода:
        
        Храните переводы в отдельных файлах ресурсов или базах данных. Используйте JSON, XML или другие форматы для хранения переводов.
        **json
        Копировать код
        // en.json
        {
            "welcome_message": "Welcome to our website!"
        }
        // fr.json
        {
            "welcome_message": "Bienvenue sur notre site web!"
        }
        3. Библиотеки и фреймворки:
        
        Используйте библиотеки и фреймворки для интернационализации (i18n), такие как i18next для JavaScript, gettext для Python или встроенные инструменты в фреймворках, таких как Angular, React, Vue.js.
        4. Атрибуты языка:
        
        Устанавливайте атрибуты языка на корневом элементе HTML и других релевантных элементах.
        **html
        Копировать код
        <html lang="en">
       5.  Автоматическое определение языка:
        
        Используйте серверные технологии или JavaScript для определения предпочтений пользователя на основе настроек браузера или IP-адреса.
        **javascript
        Копировать код
        const userLang = navigator.language || navigator.userLanguage;
        if (userLang.startsWith('fr')) {
            window.location.href = '/fr';
        }
        6.Переключатели языков:
        
        Предоставьте пользователям удобные переключатели языков для смены языка на странице. Убедитесь, что выбор языка сохраняется между сессиями.
        **html
        Копировать код
        <select onchange="changeLanguage(this.value)">
            <option value="en">English</option>
            <option value="fr">Français</option>
        </select>
        7. Тестирование:
        
        Тщательно тестируйте сайт на каждом языке, чтобы убедиться, что все элементы отображаются корректно и функциональность сохраняется.
        --Пример использования i18next в JavaScript:
        **javascript
        Копировать код
        // Установка i18next
        i18next.init({
          lng: 'en', // язык по умолчанию
          resources: {
            en: {
              translation: {
                "welcome_message": "Welcome to our website!"
              }
            },
            fr: {
              translation: {
                "welcome_message": "Bienvenue sur notre site web!"
              }
            }
          }
        }, function(err, t) {
          // Обновление контента страницы после инициализации
          document.getElementById('welcome').innerHTML = i18next.t('welcome_message');
        });
        
        // Функция для смены языка
        function changeLanguage(lang) {
          i18next.changeLanguage(lang, function(err, t) {
            // Обновление контента страницы после смены языка
            document.getElementById('welcome').innerHTML = i18next.t('welcome_message');
          });
        }
        HTML:
        html
        Копировать код
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <title>Многоязычный сайт</title>
            <script src="https://unpkg.com/i18next@21.6.0/dist/umd/i18next.min.js"></script>
            <script src="script.js"></script>
        </head>
        <body>
            <div id="welcome"></div>
            <select onchange="changeLanguage(this.value)">
                <option value="en">English</option>
                <option value="fr">Français</option>
            </select>
        </body>
        </html>
        --Таким образом, правильное внимание к деталям при проектировании и разработке многоязычных сайтов обеспечит лучший пользовательский опыт и более широкую аудиторию для вашего контента.`,
      },
      {
        question: "Вопрос 2.20: Что такое прогрессивный рендеринг?",
        answer: `Прогрессивный рендеринг — это техника оптимизации загрузки и отображения веб-страниц, которая направлена на улучшение восприятия скорости загрузки страницы пользователями. Основная идея прогрессивного рендеринга заключается в том, чтобы постепенно показывать содержимое страницы по мере его загрузки, вместо того чтобы ждать полной загрузки всех ресурсов перед рендерингом всей страницы. Это позволяет пользователям видеть и взаимодействовать с контентом быстрее.

        --Преимущества прогрессивного рендеринга
        1. Улучшение пользовательского опыта: Пользователи видят контент быстрее, что уменьшает восприятие времени ожидания.
        2. Снижение показателя отказов: Быстрое отображение контента может уменьшить количество пользователей, покидающих сайт до полной загрузки страницы.
        3. Лучшее восприятие производительности: Даже если страница все еще загружается, пользователь может начать взаимодействие с уже отображенным контентом.
        --Методы прогрессивного рендеринга
        1. Lazy Loading (ленивая загрузка):
        Отложенная загрузка ресурсов, таких как изображения и видео, до тех пор, пока они не будут необходимы (например, пока пользователь не прокрутит страницу до них).
        2. Progressive JPEGs:

        Использование прогрессивных JPEG-изображений, которые загружаются и отображаются постепенно. Сначала показывается низкокачественная версия изображения, которая постепенно заменяется на высококачественную по мере загрузки.
        3. Server-Side Rendering (SSR) с постепенной передачей:

        Отправка HTML-кода на клиентскую сторону по частям, чтобы пользователь мог видеть часть контента, пока остальная часть еще загружается.
        4. Skeleton Screens:

        Отображение "скелетного" экрана, который представляет собой базовую структуру контента, пока загружаются фактические данные.
        5. Critical CSS:

        Извлечение и встроенное добавление критических стилей, необходимых для первичной отрисовки видимой части страницы. Это позволяет быстро отобразить основную структуру и стили страницы.
        5. HTTP/2 Server Push:

        Использование возможностей HTTP/2 для отправки важных ресурсов (таких как CSS и JavaScript) вместе с начальным HTML, до того как браузер запросит их.
        -- Заключение
Прогрессивный рендеринг является важной техникой для улучшения восприятия скорости загрузки и общего пользовательского опыта на веб-сайтах. Используя такие методы, как ленивую загрузку, прогрессивные JPEG-изображения, скелетные экраны и критический CSS, вы можете значительно улучшить взаимодействие пользователей с вашим сайтом.
        `,
      },
      {
        question:
          "Вопрос 2.21: Объясните, как работает this в JavaScript. Как работает this в классах и функциях?",
        answer: `this в JavaScript — это ключевое слово, которое ссылается на текущий контекст выполнения функции. Его значение зависит от того, как функция была вызвана:

        1. В глобальной области видимости: this ссылается на глобальный объект (window в браузере, global в Node.js).
        2. В методах объекта: this ссылается на объект, которому принадлежит метод.
        3. В конструкторах и классах: this ссылается на вновь созданный экземпляр объекта.
        4. В обычных функциях: Если вызвана как функция, this ссылается на глобальный объект (или undefined в строгом режиме). Если вызвана как метод объекта, this ссылается на этот объект.
        5. В стрелочных функциях: this не имеет собственного значения, оно наследуется из окружающего контекста.
        6. С использованием call, apply и bind: this можно явно задать, определяя контекст выполнения функции.
        `,
      },
      {
        question:
          "Вопрос 2.22: Опишите, что такое всплытие и перехват событий (event bubbling и event capturing).",
        answer: `
        Всплытие и перехват событий (event bubbling и event capturing) — это два механизма обработки событий в модели событий DOM в JavaScript, которые определяют порядок, в котором события обрабатываются в дереве DOM.
        
        --Всплытие событий (Event Bubbling)
        Всплытие событий — это процесс, при котором событие, сначала обработанное целевым элементом, передается последовательно вверх по дереву DOM к его родительским элементам и далее к корневому элементу (обычно document).
        
        -Порядок обработки:
        
        1. Событие сначала обрабатывается целевым элементом.
        2. Затем событие передается его родительскому элементу.
        3. Этот процесс повторяется, пока событие не достигнет корневого элемента (document).
        --Перехват событий (Event Capturing)
        Перехват событий — это процесс, при котором событие сначала передается от корневого элемента (document) вниз по дереву DOM к целевому элементу, прежде чем быть обработанным целевым элементом.
        
        -Порядок обработки:
        
        1. Событие сначала передается корневому элементу (document).
        2. Затем событие передается его дочернему элементу.
        3. Этот процесс повторяется, пока событие не достигнет целевого элемента.
        --Событийное погружение и всплытие:
        Когда событие происходит, оно проходит через две фазы:
        
        1. Фаза перехвата (capturing phase): Событие идет сверху вниз, начиная от корневого элемента (document) и доходя до целевого элемента.
        2. Фаза всплытия (bubbling phase): После достижения целевого элемента, событие идет обратно вверх по дереву DOM от целевого элемента к корневому элементу (document).
        --Управление фазами обработки событий:
        При добавлении обработчика событий с помощью addEventListener, вы можете указать, в какой фазе будет обработано событие:
        
        1. По умолчанию обработчик событий добавляется для фазы всплытия.
        2. Если передать true в качестве третьего аргумента в addEventListener, обработчик будет добавлен для фазы перехвата.
        -Пример использования:
        1.Перехват событий (capturing phase): Если хотите обработать событие в фазе перехвата, укажите true как третий параметр в addEventListener.
        2. Всплытие событий (bubbling phase): Обработчик по умолчанию будет срабатывать в фазе всплытия.
        -Применение на практике:
        Использование всплытия и перехвата событий позволяет разработчикам контролировать порядок обработки событий, управлять сложными взаимодействиями на веб-странице и организовывать обработку событий более эффективно. Например, можно использовать перехват для предварительной обработки события перед тем, как оно достигнет целевого элемента, или использовать всплытие для обработки события на более высоком уровне, например, для делегирования событий.`,
      },
      {
        question: "Вопрос 2.23: Объясните, что такое поднятие переменных.",
        answer: `
        Поднятие переменных (hoisting) — это поведение JavaScript, при котором объявления переменных и функций перемещаются (или "поднимаются") в верхнюю часть своей области видимости перед выполнением кода. Это означает, что можно использовать переменные и функции до их фактического объявления в коде.
        
        --Как работает поднятие переменных
        1. Поднятие переменных:
        
        При объявлении переменной с помощью var, объявление переменной поднимается в верхнюю часть области видимости (функции или глобальной области), но её инициализация остаётся на месте.
        В случае с let и const, переменные также поднимаются, но не инициализируются. Они находятся в "мертвой зоне" до строки их фактического объявления.
        2. Поднятие функций:
        
        Функции, объявленные с помощью function declaration (объявления функции), полностью поднимаются в верхнюю часть области видимости, включая их определение.
        -Примеры поднятия
        Пример с var:
        **javascript
        Копировать код
        console.log(a); // undefined
        var a = 5;
        console.log(a); // 5
        В данном примере var a поднимается в верхнюю часть области видимости, но её инициализация остаётся на месте. Таким образом, первая строка выполняется как var a; console.log(a); a = 5;.
        
        Пример с let и const:
        **javascript
        Копировать код
        console.log(b); // ReferenceError: Cannot access 'b' before initialization
        let b = 10;
        console.log(b); // 10
        Для let и const переменные поднимаются, но остаются неинициализированными до строки объявления, вызывая ошибку при попытке доступа до инициализации.
        
        Пример с function declaration:
        **javascript
        Копировать код
        hoistedFunction(); // "This function has been hoisted."
        
        function hoistedFunction() {
            console.log("This function has been hoisted.");
        }
        Объявление функции hoistedFunction полностью поднимается, включая её тело, поэтому её можно вызывать до фактического объявления в коде.
        
        --Заключение
        Поднятие переменных и функций — это важное поведение JavaScript, которое может влиять на то, как интерпретируется и выполняется ваш код. Понимание этого поведения помогает избежать неожиданных ошибок и писать более предсказуемый код. Использование let и const вместо var помогает избежать проблем, связанных с поднятием и неинициализированными переменными.`,
      },
      {
        question: `Вопрос 2.24:  Объясните разницу между:
        1.function Animal() {}
        2.var animal = Animal()
        3.var animal = new Animal()`,
        answer: `-function Animal() {}: Объявление функции-конструктора.
        -var animal = Animal(): Вызов функции Animal без new, который не создает новый объект.
        -var animal = new Animal(): Вызов функции-конструктора Animal с new, который создает и возвращает новый объект.
        --Использование оператора new при вызове функции-конструктора является ключевым моментом для создания новых экземпляров объектов.`,
      },
      {
        question:
          "Вопрос 2.25: В чем разница между объектами хоста и нативными объектами?",
        answer: `В JavaScript объекты можно разделить на две основные категории: нативные (встроенные) объекты и объекты хоста. Понимание различий между ними важно для разработки веб-приложений и работы с различными средами исполнения JavaScript.

        --Нативные объекты (Native Objects)
        Нативные объекты, также известные как встроенные объекты, предоставляются самой спецификацией языка JavaScript. Эти объекты доступны в любой среде, где исполняется JavaScript, и являются частью стандарта ECMAScript.
        
        Примеры нативных объектов:
        
        -Object
        Array
        Function
        Date
        String
        Number
        RegExp
        Math
        JSON
        Эти объекты обеспечивают базовую функциональность языка, такую как создание и работа с массивами, строками, числами и другими типами данных.
        
        --Объекты хоста (Host Objects)
        Объекты хоста предоставляются окружением, в котором исполняется JavaScript. Они зависят от конкретной среды исполнения и предоставляют функциональность, специфичную для этой среды. В контексте веб-браузеров, объекты хоста обеспечивают доступ к функциональности браузера и DOM (Document Object Model).
        
        Примеры объектов хоста в браузере:
        
        window
        document
        XMLHttpRequest
        Element и другие узлы DOM (например, div, span, input)
        Консоль (console)
        Таймеры (setTimeout, setInterval)
        fetch
        localStorage и sessionStorage
        В контексте Node.js, примеры объектов хоста включают:
        
        process
        Buffer
        Модули файловой системы (fs)
        Модули HTTP (http, https)
        global
        --Ключевые различия
        1. Происхождение:
        
        Нативные объекты: Определены спецификацией ECMAScript и доступны во всех средах исполнения JavaScript.
        Объекты хоста: Предоставляются окружением исполнения (браузером, Node.js и т.д.) и могут быть специфичными для этого окружения.
        2. Доступность:
        
        Нативные объекты: Доступны во всех средах исполнения, поддерживающих JavaScript.
        Объекты хоста: Доступны только в тех средах, которые предоставляют их. Например, объекты DOM доступны только в браузерах, а объекты Node.js доступны только в среде Node.js.
        3. Функциональность:
        
        Нативные объекты: Обеспечивают основную функциональность языка JavaScript (работа с данными, объектами, функциями и т.д.).
        Объекты хоста: Предоставляют доступ к функциональности, специфичной для окружения (например, манипуляции с DOM в браузере или работа с файловой системой в Node.js).
        --Заключение
        Нативные объекты — это встроенные объекты языка JavaScript, доступные во всех средах исполнения и определенные спецификацией ECMAScript.
        Объекты хоста — это объекты, предоставляемые средой исполнения JavaScript (например, браузером или Node.js), которые обеспечивают доступ к специфической функциональности этой среды.
      
        `,
      },
      {
        question:
          "Вопрос 2.26: Приведите типичный случай использования анонимных функций.",
        answer: `Анонимные функции в JavaScript используются в различных сценариях, когда требуется передать функцию как аргумент или использовать её без явного объявления имени. Вот несколько типичных случаев использования анонимных функций:

        1. Как аргументы для других функций:
        
        **javascript
        Копировать код
        // Пример: Функция обратного вызова для метода массива
        let numbers = [1, 2, 3, 4, 5];
        numbers.forEach(function(element) {
            console.log(element);
        });
        В этом примере анонимная функция передается методу forEach в качестве функции обратного вызова.
        
        2. Самовызывающиеся анонимные функции (IIFE - Immediately Invoked Function Expressions):
        
        **javascript
        Копировать код
        (function() {
            // Код здесь
        })();
        Такие функции полезны, когда вы хотите создать область видимости для переменных, чтобы избежать конфликтов имён с другими скриптами на странице.
        
        3. Обработчики событий:
        
        **javascript
        Копировать код
        document.getElementById('myButton').addEventListener('click', function() {
            // Обработчик события
        });
        В данном случае анонимная функция используется как обработчик события для элемента.
        
        4. Замыкания (Closures):
        
        **javascript
        Копировать код
        function makeCounter() {
            let count = 0;
            return function() {
                return count++;
            };
        }
        
        let counter = makeCounter();
        console.log(counter()); // 0
        console.log(counter()); // 1
        В этом примере анонимная функция используется для создания замыкания, которое сохраняет доступ к переменной count внутри функции makeCounter.
        
        5. Асинхронные операции:
        
        **javascript
        Копировать код
        setTimeout(function() {
            console.log('Это асинхронная операция, которая выполнится через 1 секунду');
        }, 1000);
        Анонимные функции удобны при работе с асинхронными операциями, такими как setTimeout, setInterval, запросы AJAX и другие.
        
        6. Функции высшего порядка:
        
        В функциональном программировании часто используются функции высшего порядка, которые принимают или возвращают другие функции. Анонимные функции могут использоваться в качестве аргументов для таких функций.
        
        7. Массивы коллбэков:
        
        **javascript
        Копировать код
        let callbacks = [
            function() { console.log('Коллбэк 1'); },
            function() { console.log('Коллбэк 2'); }
        ];
        
        callbacks.forEach(function(callback) {
            callback();
        });
        Анонимные функции могут использоваться для создания массивов коллбэков или обратных вызовов.
        
        --Заключение
        Анонимные функции в JavaScript удобны и могут использоваться в различных сценариях, где требуется передать функцию как аргумент или выполнить код в определенном контексте без явного объявления имени функции. Это помогает сделать код более читаемым, компактным и удобным для работы с различными аспектами языка и среды исполнения.
   
        `,
      },
      {
        question:
          "Вопрос 2.27: Объясните, как в JavaScript работает прототипное наследование.",
        answer: `Прототипное наследование в JavaScript основано на концепции прототипов, которая отличается от классического наследования, присущего другим языкам программирования. Вот основные аспекты работы прототипного наследования в JavaScript:

        --Прототипы
        1. Прототип объекта:
        
        Каждый объект в JavaScript имеет свойство prototype, которое является ссылкой на другой объект, называемый прототипом.
        Прототип — это обычный объект, используемый как "родительский" для других объектов. Все объекты в JavaScript наследуют методы и свойства от своего прототипа.
        2. Свойство __proto__:
        
        Каждый объект также имеет скрытое свойство __proto__, которое указывает на его прототип.
        Если у объекта нет собственного свойства или метода, JavaScript будет искать их в его прототипе, а затем в цепочке прототипов.
        --Создание объектов
        1. Создание объектов с помощью литералов:
        
        **javascript
        Копировать код
        let person = {
            name: 'John',
            age: 30
        };
        В этом примере person является объектом, созданным с помощью литерала объекта. Его прототипом является встроенный объект Object.prototype.
        
        2. Создание объектов с помощью конструкторов:
        
        **javascript
        Копировать код
        function Person(name, age) {
            this.name = name;
            this.age = age;
        }
        
        let person1 = new Person('John', 30);
        В этом примере person1 создан с помощью конструктора Person. Конструкторы в JavaScript также используют прототипы.
        
        --Прототипное наследование
        1.Наследование свойств и методов:
        
        **javascript
        Копировать код
        function Animal(name) {
            this.name = name;
        }
        
        Animal.prototype.sayName = function() {
            console.log(My name is {this.name});
        };
        
        function Dog(name, breed) {
            Animal.call(this, name);
            this.breed = breed;
        }
        
        Dog.prototype = Object.create(Animal.prototype);
        Dog.prototype.constructor = Dog;
        
        Dog.prototype.bark = function() {
            console.log('Woof!');
        };
        
        let myDog = new Dog('Buddy', 'Labrador');
        myDog.sayName(); // My name is Buddy
        myDog.bark();    // Woof!
        -В этом примере:
        
        .Animal — это базовый конструктор.
        .Dog наследует от Animal, используя Object.create для установки прототипа Animal.prototype.
        .Методы sayName и bark доступны для экземпляра myDog благодаря прототипному наследованию.
        2. Цепочка прототипов:
        
        Прототипное наследование в JavaScript работает через цепочку прототипов: каждый объект имеет ссылку на свой прототип, который в свою очередь может иметь свой прототип и так далее, пока не достигнут конечный прототип Object.prototype.
        --Преимущества прототипного наследования:
        Гибкость: Объекты могут быть легко расширены или изменены, не затрагивая другие части кода.
        Простота и понятность: Прототипы упрощают создание объектов и управление их свойствами и методами.
        --Заключение
        Прототипное наследование в JavaScript предоставляет гибкую и мощную модель для организации и структурирования кода. Оно отличается от классического наследования, но позволяет эффективно работать с объектами и их поведением в JavaScript.`,
      },
      /*
      {
        question: "Вопрос 2.28: ",
        answer: ``,
      },
      {
        question: "Вопрос 2.29: ",
        answer: ``,
      },
      /*
       {
         question: "Вопрос 2.30: ",
         answer: ``,
       },
       {
         question: "Вопрос 2.31: ",
         answer: ``,
       },
       {
         question: "Вопрос 2.32: ",
         answer: ``,
       },
       {
         question: "Вопрос 2.33: ",
         answer: ``,
       },
       {
         question: "Вопрос 2.34: ",
         answer: ``,
       },
       {
         question: "Вопрос 2.35: ",
         answer: ``,
       },
       {
         question: "Вопрос 2.36: ",
         answer: ``,
       },
       {
         question: "Вопрос 2.37: ",
         answer: ``,
       },
       {
         question: "Вопрос 2.38: ",
         answer: ``,
       },
       {
         question: "Вопрос 2.39: ",
         answer: ``,
       },
       {
         question: "Вопрос 2.40: ",
         answer: ``,
       },
       {
         question: "Вопрос 2.41: ",
         answer: ``,
       },
       {
         question: "Вопрос 2.42: ",
         answer: ``,
       },
       {
         question: "Вопрос 2.43: ",
         answer: ``,
       },
       {
         question: "Вопрос 2.44: ",
         answer: ``,
       },
       {
         question: "Вопрос 2.45: ",
         answer: ``,
       },
       {
         question: "Вопрос 2.46: ",
         answer: ``,
       },
       {
         question: "Вопрос 2.47: ",
         answer: ``,
       },
       {
         question: "Вопрос 2.48: ",
         answer: ``,
       },
       {
         question: "Вопрос 2.49: ",
         answer: ``,
       },
       {
         question: "Вопрос 2.50: ",
         answer: ``,
       },
       {
         question: "Вопрос 2.2: ",
         answer: ``,
       },
       {
         question: "Вопрос 2.2: ",
         answer: ``,
       },
       {
         question: "Вопрос 2.2: ",
         answer: ``,
       },
       {
         question: "Вопрос 2.2: ",
         answer: ``,
       },
       {
         question: "Вопрос 2.2: ",
         answer: ``,
       },
       {
         question: "Вопрос 2.2: ",
         answer: ``,
       },
       {
         question: "Вопрос 2.2: ",
         answer: ``,
       },
       {
         question: "Вопрос 2.2: ",
         answer: ``,
       },
       {
         question: "Вопрос 2.2: ",
         answer: ``,
       },
       {
         question: "Вопрос 2.2: ",
         answer: ``,
       },
       {
         question: "Вопрос 2.2: ",
         answer: ``,
       },
       {
         question: "Вопрос 2.2: ",
         answer: ``,
       },
       {
         question: "Вопрос 2.2: ",
         answer: ``,
       },
       {
         question: "Вопрос 2.2: ",
         answer: ``,
       },
       {
         question: "Вопрос 2.2: ",
         answer: ``,
       },
       {
         question: "Вопрос 2.2: ",
         answer: ``,
       },
       {
         question: "Вопрос 2.2: ",
         answer: ``,
       },
       {
         question: "Вопрос 2.2: ",
         answer: ``,
       },
       {
         question: "Вопрос 2.2: ",
         answer: ``,
       },
       {
         question: "Вопрос 2.2: ",
         answer: ``,
       },
       {
         question: "Вопрос 2.2: ",
         answer: ``,
       },
       {
         question: "Вопрос 2.2: ",
         answer: ``,
       },
       {
         question: "Вопрос 2.2: ",
         answer: ``,
       },
       {
         question: "Вопрос 2.2: ",
         answer: ``,
       },
       {
         question: "Вопрос 2.2: ",
         answer: ``,
       },
       {
         question: "Вопрос 2.2: ",
         answer: ``,
       },
       {
         question: "Вопрос 2.2: ",
         answer: ``,
       },
       {
         question: "Вопрос 2.2: ",
         answer: ``,
       },
       {
         question: "Вопрос 2.2: ",
         answer: ``,
       },
       {
         question: "Вопрос 2.2: ",
         answer: ``,
       },
       {
         question: "Вопрос 2.2: ",
         answer: ``,
       },
       {
         question: "Вопрос 2.2: ",
         answer: ``,
       },
       {
         question: "Вопрос 2.2: ",
         answer: ``,
       },
       {
         question: "Вопрос 2.2: ",
         answer: ``,
       },
       {
         question: "Вопрос 2.2: ",
         answer: ``,
       },
       {
         question: "Вопрос 2.2: ",
         answer: ``,
       },
       {
         question: "Вопрос 2.2: ",
         answer: ``,
       },
       {
         question: "Вопрос 2.2: ",
         answer: ``,
       },
       {
         question: "Вопрос 2.2: ",
         answer: ``,
       },
       {
         question: "Вопрос 2.2: ",
         answer: ``,
       },
       {
         question: "Вопрос 2.2: ",
         answer: ``,
       },
       {
         question: "Вопрос 2.2: ",
         answer: ``,
       },
       {
         question: "Вопрос 2.2: ",
         answer: ``,
       },
       {
         question: "Вопрос 2.2: ",
         answer: ``,
       },
       {
         question: "Вопрос 2.2: ",
         answer: ``,
       },
       {
         question: "Вопрос 2.2: ",
         answer: ``,
       },
       {
         question: "Вопрос 2.2: ",
         answer: ``,
       },
       {
         question: "Вопрос 2.2: ",
         answer: ``,
       },
       {
         question: "Вопрос 2.2: ",
         answer: ``,
       },
       {
         question: "Вопрос 2.2: ",
         answer: ``,
       },
       {
         question: "Вопрос 2.2: ",
         answer: ``,
       },
       {
         question: "Вопрос 2.2: ",
         answer: ``,
       },
       {
         question: "Вопрос 2.2: ",
         answer: ``,
       },
       {
         question: "Вопрос 2.2: ",
         answer: ``,
       },
       {
         question: "Вопрос 2.2: ",
         answer: ``,
       },
       {
         question: "Вопрос 2.2: ",
         answer: ``,
       },
      */
      // {question: "",  answer: ``,},
      //{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},
      //{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},
    ];
    qaPairs.forEach((pair) => {
      let question = document.createElement("div");
      question.textContent = pair.question;
      question.classList.add("question");
      question.style.cursor = "pointer";
      question.style.fontWeight = "bold";
      question.style.border = "1px solid black";
      question.style.margin = "2px 0px 2px 0px";
      blocnotContainer.appendChild(question);

      let answer = document.createElement("div");
      answer.textContent = pair.answer;
      answer.classList.add("answer");
      answer.style.display = "none";
      answer.style.marginLeft = "20px";
      blocnotContainer.appendChild(answer);

      question.addEventListener("click", () => {
        answer.style.display =
          answer.style.display === "none" ? "block" : "none";
      });
    });
    document.body.appendChild(blocnotContainer);
  } catch (error) {
    console.error("произошла ошибка menu: ", error);
  }
}
export { createBlocnotBody2 };
